\section{Einleitung} % (fold)
\label{sec:einleitung}

\gls{ape} wird im Auftrag der Agentur \gls{inps} entwickelt. Diese erhofft sich Kostenersparnis durch Automatisierung, sowie eine solidere rechtliche Basis gegenüber ihren Kunden.

Automatisierung wird an verschiedenen Stellen eingeführt. Hält ein Entwickler ein Feature für abgeschlossen, stellt er über den Service GitHub einen so genannten Pull Request. Alle am Projekt beteiligten Entwickler werden benachrichtigt und können Anmerkungen und sogar Änderungen vornehmen, bevor das Feature übernommen wird. Dies geschieht automatisch. Außerdem wird im Projektmanagement-Tool Basecamp eine zum Pull Request passende Aufgabe erstellt. Der Kunde wird darüber sofort per E-Mail benachrichtigt.

Dieser Part ist insbesondere rechtlich interessant. Der Kunde kann das Feature nun in einer separaten Stagingumgebung ansehen und eventuell von seiner eigenen \gls{qa}-Abteilung verifizieren lassen. Ist der Kunde zufrieden, markiert er die Aufgabe als erledigt und gibt damit sein Einverständnis. Es kann vertraglich geregelt werden, dass der Kunde sich der Qualität des Features versichert hat und somit die \gls{inps} keinerlei Kosten für eventuell auf diesem Feature basierenden Ausfälle übernimmt.

Die Bestätigung des Kunden löst einen weiteren Automatisierungsmechanismus aus. Das Feature wird in den produktiven Versionierungszweig übernommen und auf dem \gls{produktivsystem} aktiviert. Der Kunde kann sein akzeptiertes Feature betrachten, ohne dass er auf den Eingriff eines Entwicklers warten muss.

Es wird ein Service entwickelt, welcher die bereits genutzten Systeme git, GitHub und Basecamp verbindet und einige Automatisierungen einführt. Die Integration ist dabei transparent. Weder Kunde noch Entwickler sieht jemals eine grafische Oberfläche des Services. Beide Parteien profitieren jedoch von den Automatisierungen und Absicherungen, welche der Service bietet.

\gls{ape} wird als unabhängiger Web-Service mit Hilfe des Frameworks \gls{ror} in der Programmiersprache \gls{ruby} entwickelt. Die Herausforderungen bei der Planung und Implementierungen sind speziell in den zahlreichen Schnittstellen zu finden. Sechs Architekturkomponenten kommunizieren miteinander über Protokolle wie HTTP, SSH und FTP; mit Datenformaten JSON und XML; und Tools wie git und rsync.

Diese Arbeit zeigt, wie die beschriebenen Ideen als Web-Service implementiert werden können. Kapitel \ref{sec:konzepte_und_werkzeuge} erläutert die theoretischen Konzepte und Ideen hinter dem Service, sowie einige wesentliche Werkzeuge, welche zum Verständnis der Implementierung notwendig sind. Kapitel \ref{sec:architektur_und_umsetzung} präsentiert Details der vorliegenden Architektur und gibt einen Einblick in die Implementierung. Kapitel \ref{sec:zusammenfassung_und_ausblick} schließt die Arbeit mit einer Zusammenfassung ab.

% section einleitung (end)

\section{Konzepte und Werkzeuge} % (fold)
\label{sec:konzepte_und_werkzeuge}

Dieses Kapitel widmet sich den Grundlagen, die zum Verständnis der vorliegenden Arbeit notwendig sind.

\subsection{Begriffseinführungen} % (fold)
\label{sub:begriffseinfuehrungen}

Um prägnante, exakte Formulierungen zu ermöglichen, werden in diesem Kapitel benötigte Begriffe definiert.

\subsubsection{deployen} % (fold)
\label{ssub:deployen}
\emph{deployen} beschreibt die Tätigkeit, ein System oder ein Teilsystem einzusetzen. Die exakte Zusammensetzung und Abfolge von Aktivitäten ist von der jeweiligen Situation abhängig. Im Allgemeinen bedeutet im Rahmen dieser Arbeit etwas \emph{zu deployen}, Dateien vom Entwicklungssystem in ein Zielsystem zu übertragen, so dass Änderungen aus dem Entwicklungssystem im Zielsystem sichtbar werden. Abweichungen von dieser Definition werden im Text erläutert.
% subsubsection deployen (end)

\subsubsection{mergen} % (fold)
\label{ssub:mergen}
\emph{mergen} beschreibt die Tätigkeit, etwas zusammenzuführen. Im Rahmen dieser Arbeit werden ausschließlich Branches innerhalb des Versionskontrollsystems git zusammengeführt. An einigen Stellen wird vom mergen von Features gesprochen. Das ändert nichts, da ein Feature exakt einem Branch entspricht.

Eine derartige Formulierung kann immer genau auf eine Folge von Befehlen zurückgeführt werden, wie am Beispiel in Listing \ref{lst:mergen} gezeigt wird.

\begin{figure}
	\begin{lstlisting}[caption=Mergen von zwei Branches,label={lst:mergen}]
	// <branch1> wird in <branch2> gemerged
	$> git checkout <branch2>
	$> git merge <branch1>
	\end{lstlisting}
\end{figure}

% subsubsection mergen (end)

% subsection begriffseinfuehrungen (end)

\subsection{Konzepte} % (fold)
\label{sub:konzepte}

\gls{ape} ist ein Deployment-System. Dieses Kapitel erklärt, was im Rahmen dieser Arbeit unter \emph{Deployment} (von englisch \emph{to deploy}: \emph{einsetzen}, \emph{anwenden}) zu verstehen ist.

\subsubsection{Deployment} % (fold)
\label{ssub:deployment}

Im Bereich der Softwareentwicklung beschreibt es den Vorgang, ein entwickeltes Projekt oder Teilprojekt in einen Zustand zu überführen, so dass es vom Endbenutzer eingesetzt werden kann.

Arbeitet ein Entwickler an einem Projekt, hat er seine lokalen Werkzeuge zur Verfügung und kann seine Arbeitsumgebung so konfigurieren, dass das Projekt am besten funktioniert. Diese Bedingungen unterscheiden sich jedoch vom \gls{produktivsystem}. Diese Tatsache muss beim Deployment beachtet werden.

Wird in Programmierprachen entwickelt, deren Quellcode kompiliert werden muss, entstehen zusätzliche Schwierigkeiten. Der korrekte Compiler muss in der korrekten Version verwendet werden. Während der Entwickler in der Programmierphase den Compile-Button seiner \gls{ide} verwenden kann, steht diese Funktion dem Endbenutzer nicht zur Verfügung. Dieser ist auf eine ausführbare Datei angewiesen.

Im Rahmen dieser Arbeit werden jedoch ausschließlich Webprojekte besprochen. Diese werden dynamisch interpretiert, nicht compiliert. Damit entfällt die besprochene Hürde.

Webentwicklung erfordert, dass das Projektverzeichnis zum Zielsystem übertragen wird. Dies geschieht entweder manuell oder automatisiert. Letztgenanntes ist erstrebenswert. Der Grund dafür wird unter anderem in Kapitel \ref{ssub:continuous_deployment} besprochen.

% subsubsection deployment (end)

\subsubsection{Continuous Deployment} % (fold)
\label{ssub:continuous_deployment}

Mit wachsender Projektgröße steigt der Aufwand des Deployments. Außerdem besteht immer die Möglichkeit, dass beim Einspielen einer neuen Version in das \gls{produktivsystem} Fehler entstehen. Je größer die Änderungen, desto höher ist die Wahrscheinlichkeit der Einführung neuer Fehler\comment{externe ref}. Continuous Deployment ist ein Ansatz, diese Probleme zu lösen oder zumindest einzugrenzen.

\emph{Continuous}, englisch \emph{kontinuierlich}, \emph{ständig} oder \emph{stetig}, beschreibt einen wesentlichen Aspekt. Es ist in der Software-Entwicklung üblich, in Releases zu entwickeln. Das heißt, es wird für Wochen oder Monate im Voraus geplant, woran gearbeitet wird. Erst, wenn dieser Plan abgearbeitet wurde, werden alle Änderungen zugleich deployed. Dies ist im Bereich des Webs aber weder erforderlich noch wünschenswert.

Es gibt mehrere Gründe, diesen Ansatz zu vermeiden. Zum einen steigt, wie bereits erwähnt, mit der Größe der Änderungen auch die Wahrscheinlichkeit eines Fehlers. Zum anderen muss Releasemanagement betrieben werden, um kritische Patches sowohl im \gls{produktivsystem} als auch im gerade entwickelten Release einfließen zu lassen. Weiterhin ist es im Sinne des Endkunden, wenn dieser schneller von neuen Features profitiert, als es mit dem manuellen Freischalten durch einen Entwickler möglich wäre. Schließlich ist es um so schwieriger, einen Fehler einer Änderung zuzuordnen, je mehr Änderungen mit einem Mal deployed werden.

Mit Continuous Deployment ist es möglich, täglich oder sogar mehrmals täglich kleine Änderungen zu veröffentlichen. Kritische Patches können sofort im normalen Entwicklungsprozess behandelt werden. Endbenutzer profitieren sofort von Features. Auftretende Fehler können leichter als zuvor der soeben eingeführten Änderung zugeordnet werden, da sich die Menge der Quellcodeänderungen je Deploymentvorgang verringert.

Dies ist jedoch nur realisierbar, wenn der Aufwand des Deployments klein ist. Das heißt, es soll so viel wie möglich automatisiert werden. Je weniger der Entwickler eingreifen muss, desto mehr Zeit kann er mit der Entwicklung von Features verbringen. Ist der Aufwand des Deployments zu groß, wird der Entwickler verleitet, mehrere Features zu einem Release zusammenzufassen, was dem Grundgedanken des Continuous Deployments widerspricht. Es handelt sich hierbei um eine psychologische Schranke. Diese Schranke kann sich jedoch von Entwickler zu Entwickler unterscheiden. Schließlich kann nur das Ziel verfolgt werden, den Aufwand immer weiter zu verringern.

Angenommen, es existiert ein Deployment-System mit genügend geringem Aufwand, so dass kein Entwickler dazu tendiert, das System zu umgehen. Dann ist es auch möglich, auf beliebig viele Systeme zu deployen. Das ermöglicht die Existenz eines \glspl{stagingsystem}. Dieses kann identisch zum \gls{produktivsystem} sein -- mit dem einzigen Unterschied, dass es für Endbenutzer nicht erreichbar ist. Dann kann eine Änderung zuerst dorthin deployed und unter realistischen Bedingungen überprüft werden. So können Fehler bereits auf diesem System entdeckt und behoben werden, bevor das neue Feature das \gls{produktivsystem} erreicht.

Das wiederum erlaubt eine größere Flexibilität im Arbeitsablauf. Eine \gls{qa} Abteilung kann selbstständig ein Testverfahren entwickeln und dieses jedes Mal durchlaufen, wenn eine neue Änderung das \gls{stagingsystem} erreicht.

\gls{ape} kommt zum Einsatz, um Continuous Deployment zu ermöglichen. Deployment wird vollkommen automatisiert. Ein Projekt muss lediglich zu Beginn einmalig konfiguriert werden. Anschließend übernimmt \gls{ape} das Deployment. Wie das möglich ist, wird ab Kapitel \ref{sec:architektur_und_umsetzung} erläutert.

% subsubsection continuous_deployment (end)

% subsection konzepte (end)

\subsection{Werkzeuge} % (fold)
\label{sub:werkzeuge}

Nachfolgend werden einige Werkzeuge und Teile der Funktionen erläutert, die zum Verständnis der Arbeit notwendig sind.

\subsubsection{SSH \& Asymmetrische Authentifizierung} % (fold)
\label{ssub:ssh_&_asymmetrische_authentifizierung}

Wie in Kapitel \ref{sub:architektur} gezeigt wird, müssen verschiedene Systeme miteinander kommunizieren. Diese Kommunikation muss sowohl automatisch, als auch sicher stattfinden.

An mehreren Stellen wird \gls{ssh} zum Einsatz kommen. Dieses Protokoll erfüllt die genannten Bedingungen. Die Kommunikation ist mächtig, da über das Protokoll Shell-Befehle ausgeführt werden können. Die Authentifizierung kann durch die Verwendung eines asymmetrischen Schlüsselpaars automatisiert werden. Bei einer passwortbasierten Authentifizierung muss das Passwort interaktiv eingegeben werden, was eine Automatisierung verhindert. Asymmetrische Authentifizierung gilt als sicher.\cite{asymmetric_crypto}

% subsubsection ssh_&_asymmetrische_authentifizierung (end)

\subsubsection{git} % (fold)
\label{ssub:git}

Ein Werkzeug des Deployment-Workflows ist \gls{git}. Es wird zur dezentralen Versionskontrolle verwendet. Im Zusammenspiel mit \gls{github} bildet es die Basis des Workflows.

Zum Verständnis der weiteren Arbeit ist es notwendig, einige grundlegende Kommandozeilenbefehle zu verstehen. Diese werden nun erklärt:

\paragraph{\lstinline!git clone <repository>!} % (fold)
\label{par:git_clone}
Klont ein \gls{repository} in ein lokales Verzeichnis. Dabei wird die Referenz zum Ursprungsrepository behalten, so dass dieses nicht bei jedem weiteren Befehl angegeben werden muss. Um es dennoch referenzieren zu können, bekommt es den Namen \emph{origin} und kann bei Bedarf damit angesprochen werden.
% paragraph git_clone (end)

\paragraph{\lstinline!git pull!} % (fold)
\label{par:git_pull}
Holt alle Änderungen aus dem \gls{repository} (im Rahmen des vorgestellten Workflows gibt es nur ein zentrales \gls{repository}: \gls{github}).
% paragraph git_pull (end)

\paragraph{\lstinline!git push!} % (fold)
\label{par:git_push}
Sendet Änderungen aller lokalen Branches mit korrespondierendem entfernten Branch zum entsprechenden \gls{repository} (im Rahmen dieser Arbeit ausschließlich \gls{github}).
% paragraph git_push (end)

\paragraph{\lstinline!git checkout [-b] <branch>!} % (fold)
\label{par:git_checkout}
Holt einen Branch in das \gls{working directory}. Mit anderen Worten, es wird der angegebene Branch aktiviert und damit der Projektstatus dieses Branches hergestellt.

Wird der Parameter \lstinline!-b! verwendet, passieren zwei Dinge. Zuerst wird ein Branch des angegebenen Namens erstellt. Anschließend wird dieser ausgecheckt. In Kapitel \ref{ssub:staging_und_produktiv_deployment} wird folgender Befehl benötigt:

% \lstinline!git checkout -b live origin/live!.
\[
	\textrm{git checkout -b live origin/live}
\]

Dabei bezeichnet \lstinline!live! den lokal zu erstellenden Branch und \lstinline!origin/live! den aus\-zu\-check\-en\-den Branch auf \gls{github}.

% paragraph git_checkout (end)

\paragraph{\lstinline!git status!} % (fold)
\label{par:git_status}
Zeigt den Status des aktuellen \glspl{working directory}.
% paragraph git_status (end)

% subsubsection git (end)

\subsubsection{rsync} % (fold)
\label{ssub:rsync}

Um Daten von einem lokalen zu einem entfernten System zu kopieren, kann rsync verwendet werden. Es unterstützt rekursive Datentransfers, sowie Authentifizierung über \gls{ssh}.

Rsync kommt zum Einsatz, um Projektverzeichnisse auf Zielsysteme zu kopieren. Dies ist jedoch nur möglich, wenn diese \gls{ssh}-Authentifizierung unterstützen. Als Alternative kommt das \gls{ftp} (Kapitel \ref{ssub:ftp}) zum Einsatz.

% subsubsection rsync (end)

\subsubsection{FTP} % (fold)
\label{ssub:ftp}

\gls{ftp} kommt im Rahmen dieser Arbeit als Ausweichsoption für \gls{rsync} zum Einsatz. Es wird benutzt, um Projektverzeichnisse von einem lokalen System auf ein Zielsystem zu kopieren. Die Authentifizierung findet über einen Benutzernamen sowie ein Passwort statt. \gls{ftp} ist langsamer als \gls{rsync}, kommt also nur zum Einsatz, wenn \gls{rsync} nicht möglich ist.

% subsubsection ftp (end)

\subsubsection{Ruby \& Ruby on Rails} % (fold)
\label{ssub:ruby_ruby_on_rails}

\gls{ape} wird mit \gls{ror} entwickelt.

\gls{ror} ist ein Open Source Full-Stack Web Application Framework für die Programmiersprache Ruby. Full-Stack bedeutet, dass das Framework -- und damit der Programmierer -- Zugriff auf Informationen des Webservers hat, Datenbankabfragen senden kann und ein Templatingsystem zur Verfügung stellt.

% subsubsection ruby_ruby_on_rails (end)

\subsubsection{WordPress} % (fold)
\label{ssub:wordpress}

\begin{wrapfigure}{l}{0.45\textwidth}
	\begin{tikzpicture}[%
		grow via three points={one child at (0.5,-0.7) and
		two children at (0.5,-0.7) and (0.5,-1.4)},
		edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
		\tikzstyle{every node}=[anchor=west]
		\node {wp-content/}
		child { node {index.php}}		
		child { node {plugins/}
			child  { node {akismet/}}
			child  { node {bbPress/}}
		}
		child [missing] {}				
	    child [missing] {}
		child { node {themes/}
			child  { node {twentyeleven/}}
			child  { node {twentyten/}}
		}
		child [missing] {}				
	    child [missing] {}
		child { node {upgrade/}}
		child { node {uploads/}}
		;
	\end{tikzpicture}
	 \caption{Beispiel \lstinline!wp-content! Verzeichnis}
	 \label{fig:example_wp_content_dir}
\end{wrapfigure}

\gls{ape} wird darauf ausgelegt, \gls{wordpress}-Systeme zu deployen. Das heißt nicht, dass keine anderen Systeme damit verwaltet werden können. Da vorerst jedoch ausschließlich auf \gls{wordpress} basierende Projekte zum Einsatz kommen sollen, wird auch im Rahmen dieser Arbeit nichts anderes betrachtet.

\gls{wordpress} ist eine freie Open Source Blogging Plattform und kann auch als \gls{cms} verwendet werden. Es basiert auf \gls{php} und \gls{mysql}. Unter anderem wegen seiner Plugin-Architektur und seinem Template-System eignet es sich, um verschiedenste Ansprüche erfüllen zu können.

Für das \gls{deployment} ist lediglich der in Abbildung \ref{fig:example_wp_content_dir} skizzierte Ordner \lstinline!wp-content/! von Bedeutung. Alle außerhalb dieses Ordners liegenden Dateien gehören zu \gls{wordpress} selbst und dürfen nicht verändert werden, da sie nach einem \gls{wordpress} Update ohnehin wieder zurückgesetzt werden. Die einzige Ausnahme ist die Datei \lstinline!wp-config.php!, welche systembezogene Konfigurationen, wie Datenbank-Zugangsdaten, enthält. Es wird ausschließlich in den Ordnern \lstinline!plugins/! und \lstinline!themes/! entwickelt. Jedes Plugin bzw. jedes Theme befindet sich in einem eigenen Unterordner. \lstinline!upgrade/! wird von WordPress bei Updates als temporäres Verzeichnis benutzt und \lstinline!uploads/! beinhaltet von Endnutzern hochgeladenen Dateien.

Themes sind Dateien, welche Design und Funktionalität einer \gls{wordpress} Seite definieren. Plugins können unabhängig vom Theme eine Seite um Funktionalität erweitern oder bestehende Features verändern.

Veränderungen an der Datenbank werden von den Plugins und Themes selbst administriert. Das ist vorteilhaft, da das \gls{deployment} sich dann nicht darum kümmern muss. Es ist ausreichend, das \lstinline!wp-content/! Verzeichnis zu aktualisieren.

% subsubsection wordpress (end)

% subsection werkzeuge (end)

% section konzepte_und_werkzeuge (end)

\section{Architektur und Umsetzung} % (fold)
\label{sec:architektur_und_umsetzung}

Dieses Kapitel behandelt die Details des entstandenen Services. Zunächst wird erläutert, welches Problem \gls{ape} löst und weshalb genau dieser und kein anderer Ansatz gewählt wird. Anschließend werden Konzept und Architektur des Services analysiert, sowie einzelne Kernelemente der Software im Detail besprochen.
	
\subsection{Ziel des Services} % (fold)
\label{sub:ziel_des_services}

Software-Projekte haben unterschiedlichen Umfang. An den kleinsten Projekten arbeiten einzelne Mitarbeiter, an anderen Projekten arbeiten zwei oder mehr. Es gibt Projektleiter, welche Arbeit an die Entwickler verteilen und den größtmöglichen Teil der Kommunikation mit den Kunden übernehmen, damit die Entwickler ungestört arbeiten können. Dies sind die wesentlichen Rollen im Arbeitsfluss: Projektleiter, Entwickler und Kunde.

Der optimale Informationsfluss (Abbildung~\ref{fig:ideale-beziehung}) ist jedoch unrealistisch. Spätestens wenn das Projekt in Betrieb ist und Fehler berichtet werden, ist die Projektleiter-Schicht zum Teil eine unnötige Barriere. Um dennoch zu gewährleisten, dass der Kunde den Entwickler nicht direkt mit E-Mails oder Anrufen stört, wird das Projekt-Management Tool \Gls{basecamp} benutzt. Dort werden Fehlerberichte, sowie Featureanfragen in Aufgaben-Listen verwaltet (Abbildung~\ref{fig:tatsaechliche-beziehung}).

Im Rest dieser Arbeit wird nicht mehr zwischen Fehlerbericht und Featureanfrage unterschieden werden. Aus Sicht des Arbeitsablaufs gibt es keinen Unterschied, daher ist es unnötig, beide Fälle zu betrachten. Es wird nur noch von Features die Rede sein.

\begin{figure}
	\centering
	\subfloat[Optimal] {
		\label{fig:ideale-beziehung}
		\begin{tikzpicture}%[scale=1.0,transform shape]
			\node (pm) {Projektleiter};
			\node (customer) [below=of pm] {Kunde}
				edge [<->] (pm)
			;
			\node (dev) [above=of pm] {Entwickler}
				edge [<->] (pm)
			;
		\end{tikzpicture}
	}
	\subfloat[Tatsächlich] {
		\label{fig:tatsaechliche-beziehung}
		\begin{tikzpicture}%[scale=1.0,transform shape]
			\node (center) {};
			\node (customer)	[left=of center]	{Kunde};
			\node (dev) 		[right=of center]	{Entwickler};
			\node (bc)			[above=of center]	{Basecamp}
				edge [<->,bend right] (customer)
				edge [<->,bend left] (dev)
			;
			\node (pm)			[below=of center]	{Projektleiter}
				edge [<->,bend left] (customer)
				edge [<->,bend right] (dev)
			;
		\end{tikzpicture}
	}
	
	\caption{\subref{fig:ideale-beziehung} Optimaler und \subref{fig:tatsaechliche-beziehung} tatsächlicher Informationsfluss}
	\label{fig:personen_beziehungen}
\end{figure}

% subsubsection inps (end)

\subsubsection{Entwicklung eines Features} % (fold)
\label{ssub:entwicklung_eines_features}

Abhängig vom Projekt gibt es Abweichungen im Arbeitsablauf. Doch die prinzipielle Vorgehensweise ist immer die gleiche. Diese wird nun beschrieben.

Der Kunde formuliert die Spezifikation für ein Feature oder eine Menge von Features. Diese werden vom Projekleiter begutachtet und eventuelle Unklarheiten werden im Dialog mit dem Kunden beseitigt. Ist das Projekt bereits fortgeschritten, formuliert der Kunde seine Wünsche direkt im Basecamp. Erfahrungsgemäß sind dies dann nur noch Anpassungen und Fehlerberichte, so dass der Projektleiter nicht mehr jede Anfrage kontrollieren muss.

Ein Entwickler weist sich eigenverantwortlich eine Teilaufgabe zu und beginnt, diese zu bearbeiten. Dazu stellt er sicher, dass er lokal die aktuelle Variante des Projekts vorliegen hat und beginnt, das Feature umzusetzen. Im Moment ist es dem Entwickler überlassen, ob er in separaten Branches arbeitet oder nicht. Sind mehrere Entwickler an einem Projekt beteiligt, sollen diese sich lediglich auf eine Vorgehensweise einigen.

Ist das Feature fertig entwickelt, werden die Änderungen manuell in ein Stagingsystem übertragen und der Kunde benachrichtigt. Der Kommunikationskanal ist dabei wieder projektabhängig. Ist der Kunde zufrieden, muss das Feature manuell auf das \gls{produktivsystem} übertragen werden.

Da der Vorgang insgesamt sehr aufwändig ist, wird vorwiegend in Releases gearbeitet. Das heißt, dass einige Tage oder Wochen Features entwickelt und in unregelmäßigen Abständen auf das Stagingsystem übertragen werden. An einem definierten Datum gibt es einen \gls{feature_freeze}. Einen Tag lang wird nur noch an der Stabilität des Releases gearbeitet und der Release selbst vorbereitet und durchgeführt. Verläuft dieser erfolgreich, beginnt der Zyklus erneut.

Diese Vorgehensweise funktioniert, ist jedoch umständlicher als sie sein müsste. Die Webplattform ist prädestiniert für tägliche oder mehrmals tägliche Releases. Es muss lediglich ein passender Workflow gefunden werden.

Weiterhin besteht im Moment das Problem, dass zwischen Projekten Unterschiede herrschen, die zwar klein aber doch vorhanden sind. Das sorgt dafür, dass Entwickler nicht konfliktfrei zwischen Projekten wechseln können. Der Vorgang ist immer mit Verwirrung und Absprachen verbunden, die bei Vorhandensein und Einhaltung von Konventionen nicht nötig sind.

Dieses Problem soll \gls{ape} lösen. Es ist ein Workflow zu entwerfen, welcher Konventionen einführt, der die oben genannten Abläufe vereinheitlicht. Automatisierungen sind, wo möglich, mit Hilfe der Software umzusetzen.

% subsubsection entwicklung_eines_features (end)

\subsection{Einheitlicher Workflow} % (fold)
\label{sub:einheitlicher_workflow}

Zunächst wird festgelegt, dass jedes Feature in seinem eigenen \gls{git}-Branch entwickelt wird. Das hat mehrere Vorteile. Entwickler in einem Projekt müssen sich weniger absprechen, da jeder in seinem eigenen Branch arbeitet. Ein Entwickler kann bei Prioritätenverschiebung zudem sofort die Arbeit an einem Feature anhalten und in einem parallelen Branch das wichtigere Feature bearbeiten. Auf Codeebene lässt sich mit einem einzigen \gls{git}-Befehl ermitteln, welche Zeilen das Feature verändert.

Weiterhin werden \gls{github} \glspl{pull request} ein fester Bestandteil des Workflows. Dies sind automatisierte Anträge, einen Branch in einen anderen zu mergen. Ein \gls{pull request} zeigt die Versionshistorie des Features und die Summe aller Änderungen. Andere Entwickler können das Feature überprüfen, Anmerkungen hinterlassen und selbst Änderungen am Feature vornehmen. Sind alle Entwickler mit der Codequalität zufrieden, wird der \gls{pull request} akzeptiert und \gls{github} merged die Branches automatisch.

Es gibt zwei persistente \gls{git} Branches. \emph{dev} und \emph{live}. Letztgenannter ist unter allen Umständen stabil zu halten und wird darum nur in Ausnahmefällen manuell beeinflusst. Er ist ein Abbild des \gls{produktivsystem}s. Fertig entwickelte und vom Kunden bestätigte Features werden vom \gls{ape} in ihn gemerged. Analog dazu repräsentiert der \emph{dev} Branch das \gls{stagingsystem}. \gls{ape} merged Branches in \emph{dev}, wenn auf \gls{github} ein Pull Request akzeptiert wurde.

Ein \gls{pull request} wird vom Entwickler genau dann erstellt, wenn er mit der Entwicklung eines Features fertig ist und dieses bereit für das \gls{stagingsystem} ist. Wird dieser akzeptiert, sollen automatisch zwei Aktionen geschehen. Zum einen muss das Feature auf dem \gls{stagingsystem} verfügbar werden. Zum anderen soll der Kunde benachrichtigt werden, dass dieses Feature nun bereit zur Übergabe an die \gls{qa} ist. Beide Aufgaben werden vom \gls{ape} übernommen.

Der \gls{ape}-Service wird von GitHub per \Gls{webhook} informiert, dass ein Pull Request akzeptiert wurde. Zuerst wird das \gls{stagingsystem} aktualisiert. Dazu müssen lediglich die Dateien aus dem Staging-Branch übertragen werden, da \gls{github} bereits das Mergen der Branches übernommen hat. Anschließend wird über eine API in \gls{basecamp} eine Aufgabe angelegt, welche den Kunden über das Feature im Stagingsystem informiert und ihn um Rückmeldung bittet. Basecamp verschickt automatisch eine E-Mail an den Kunden, so dass zwischen Akzeptanz des \glspl{pull request} und der automatischen Benachrichtigung des Kunden lediglich Sekunden oder Minuten liegen.

Gibt es Probleme, kann der Kunde diese über das Kommentarsystem in \gls{basecamp} äußern und der Entwickler kann diese bearbeiten. Ist der Kunde sofort oder nach Behebung aller Probleme zufrieden, markiert er die Aufgabe als erledigt. \gls{ape} registriert die Veränderung des Status der Aufgabe automatisch und beginnt, das Feature auf das \gls{produktivsystem} zu übertragen. Dazu merged er selbstständig den Featurebranch in den Produktivbranch und überträgt das Ergebnis auf das \gls{produktivsystem}.

Damit ist ein Featurezyklus abgeschlossen. Ist das Feature klein (z.B. nur eine Codezeile muss angepasst werden) und reagieren alle Parteien schnell, kann der gesamte Zyklus einschließlich Programmierung in weniger als 15 Minuten abgearbeitet werden. Damit können selbst kritische Änderungen schnell vorgenommen werden. Es können beliebig viele dieser Zyklen parallel aktiv sein und ein Entwickler kann an verschiedenen Features gleichzeitig arbeiten, ohne dass sich deren Entwicklungszweige behindern.

% subsection einheitlicher_workflow (end)

\subsection{Architektur} % (fold)
\label{sub:architektur}

Das in dieser Arbeit betrachtete Gesamtsystem kann in sechs Komponenten unterteilt werden. Abbildung \ref{fig:ape_network} illustriert diese Unterteilung. Die sechs Komponenten sind: \circled{1} die Entwickler der \gls{inps}, \circled{2} \gls{github}, \circled{3} der \gls{ape}-Service, \circled{4} die \gls{ape} Repositories, \circled{5} \gls{basecamp} und \circled{6} die Staging- und Produktivsysteme der Kunden.

\begin{figure}
	\includegraphics[width=1.0\textwidth]{assets/ape_network.eps}
	\caption{APE Netzwerk}
	\label{fig:ape_network}
\end{figure}

Zwischen den Entwicklern und \gls{github} gibt es zwei Schnittstellen. \gls{git} und die Webseite von \gls{github}: \url{https://github.com/}. \gls{git} kommt zur Verwaltung des Quellcodes zum Einsatz. Über die Webseite können die Entwickler miteinander kommunizieren und \glspl{pull request} erstellen.

\gls{github} sendet über eine Web-API automatisiert Informationen an \gls{ape}. Diese Schnittstelle kann über die \gls{github} Webseite konfiguriert werden.

\gls{basecamp} Aufgaben werden vom \gls{ape} erstellt. Dies geschieht über eine XML-basierte \gls*{rest} API, welche von \gls{basecamp} bereitgestellt wird. Die Authentifizierung funktioniert über ein von \gls{basecamp} generiertes API Token.

Ein Server mit den \gls{ape} Repositories enthält die geklonten \lstinline!git! Repositories. Der Klonvorgang geschieht per direktem Zugriff auf \gls{github} über ein asymmetrisches Authentifizierungsverfahren. Dazu muss im jeweiligen \gls{github} Projekt der Public Key hinterlegt werden. Im Deployment-Vorgang loggt sich der \gls{ape} Service über SSH in die \gls{ape} Repositories ein. Auch dazu wird ein asymmetrisches Authentifizierungsverfahren verwendet.

Schließlich gibt es außerdem die Staging- und Produktivsysteme der Kunden. Je nach Projekt existiert ein \gls{stagingsystem} für den Stagingbetrieb und ein \gls{produktivsystem} für die für die Welt sichtbare Webseite. Daten werden ausschließlich von den \gls{ape} Repositories zum entsprechenden Zielsystem transferiert. Dieser Transfer geschieht je nach Kundenwunsch entweder über \gls{ftp} oder \gls{rsync}.

Damit sind alle Komponenten betrachtet. Je nach Kunde kann es Abweichungen geben aber das Gesamtbild bleibt gleich. \gls{ape} Service und \gls{ape} Repositories könnten zum Beispiel auf dem selben System liegen. Aus Flexibilitätsgründen wurde jedoch die vorliegende Variante implementiert.

% subsection architektur (end)

% subsection ziel_des_services (end)

\subsection{Implementierungsdetails} % (fold)
\label{sub:implementierungsdetails}

Die Schwierigkeit bei der Entwicklung des \gls{ape}-Services liegt im reibungslosen Verknüpfen der verschiedenen Services. Ein Schema der existierenden Schnittstellen ist in Abbildung\ref{fig:ape_network} zu sehen. In den Kapiteln \ref{ssub:interpretation_von_git_commits} bis \ref{ssub:uebertragung_der_dateien} werden einige ausgewählte nichttriviale Aspekte der Schnittstellenimplementierung besprochen.

\subsubsection{Interpretation von Git-Commits} % (fold)
\label{ssub:interpretation_von_git_commits}

Eine kritische Schnittstelle ist die Kommunikation zwischen \gls{github} und \gls{ape}. Jedes Mal, wenn ein Entwickler eine oder mehrere Änderungen über einen \lstinline!git push! zu \gls{github} transferiert, generiert \gls{github} bei Bedarf eine \gls{json}-formatierte Nachricht mit allen relevanten Informationen zum Repository, sowie zu den im \lstinline!push! enthaltenen Commits. Ein Beispieldatensatz ist in Listing \ref{lst:example_payload} zu sehen.

\begin{figure}
	\begin{lstlisting}[caption=Beispiel-Webhook von \gls{github},label={lst:example_payload}]
	{ "before": "f7a3133afc170eebcc97349bae547558088a50cb",
	  "repository": {
	    "url": "http://github.com/inpsyde/ape", "name": "ape",
	    "description": "Automatic Push Environment",
	    "watchers": 5, "forks": 2, "private": 1,
	    "owner": { "email": "e.teubert@inpsyde.com",
	               "name": "eteubert" }
	  }, "commits": [ {
	      "id": "177e12cbcc29c84765f4232c87efb6a6c4cfb194",
	      "url": "https://github.com/inpsyde/ape/commit/177e\
					12cbcc29c84765f4232c87efb6a6c4cfb194",
	      "author": {
	        "email": "e.teubert@inpsyde.com",
	        "name": "Eric Teubert"
	      },
	      "message": "escape bash dollars",
	      "timestamp": "2011-12-19T14:57:17-08:00",
	      "added": ["ftp_tree.rb"]
	    } ],
	  "after": "177e12cbcc29c84765f4232c87efb6a6c4cfb194",
	  "ref": "refs/heads/dev" }
	\end{lstlisting}
\end{figure}

Diese Datensätze kann \gls{github} über einen so genannten Webhook an eine ausgewählte URL senden, zum Beispiel \url{http://www.ape-service.com/github/webhook}. Mit Hilfe der \lstinline!repository!-Informationen wird das zu verwaltende Projekt bestimmt. Aus den Inhalten von \lstinline!ref! und \lstinline!commits! leitet \gls{ape} ab, welche Aktion auszuführen ist.

Aus \lstinline!ref! lässt sich der Branch Name ableiten. Ist dieser weder \lstinline!dev! noch \lstinline!live!, wurde ein Feature entweder erstellt oder aktualisiert -- je nachdem, ob \gls{ape} das Feature bereits kennt oder nicht.

Ist \lstinline!dev! der abgeleitete Branchname, wurde ein Feature in diesen Branch gemerged und muss gestaged werden. Das Feature muss aus dem Inhalt des Commits abgeleitet werden. \gls{github} erzeugt bei akzeptierten Pull Requests Commit-Nachrichten der Form:

\[
	\textrm{``Merge pull request \#1 from <reponame>/<featurebranch>''}
\]

Da diese Zeile immer gleich aufgebaut ist, lässt sich so zuverlässig der Featurebranch ermitteln.

Ähnlich verhält es sich, wenn \lstinline!live! der abgeleitete Branch Name ist. Lediglich die Nachricht hat nun eine andere Form, da diese nicht durch einen Pull Request, sondern durch einen vom \gls{ape} durchgeführten \lstinline!git merge! generiert wird. Eine Nachricht hat die feste Struktur \lstinline!"Merge branch '<featurebranch>'"! und kann damit ohne Probleme geparsed werden. Schließlich wird der \lstinline!live! Branch auf das \gls{produktivsystem} deployed.

% subsubsection interpretation_von_git_commits (end)

\subsubsection{Staging und Produktiv-Deployment} % (fold)
\label{ssub:staging_und_produktiv_deployment}

Die Vorgänge beim Deployment unterscheiden sich kaum. Der Vorgang des Produktiv-Deployment, also das Deployen des \lstinline!live! Branches in das \gls{produktivsystem}, enthält einen zusätzlichen Schritt, daher wird dies als Beispiel herangezogen.

Zunächst öffnet \gls{ape} einen SSH Tunnel, um sich in den \gls{reposerver} einzuloggen. Dort wird, falls er noch nicht existiert, ein Ordner für das Projekt angelegt. Mit \lstinline!git status! wird anschließend überprüft, ob das Projekt bereits aus \gls{github} geklont wurde. Falls nicht, wird dies nun nachgeholt. Schlägt der Klonvorgang fehl, gibt es ein Authentifizierungsproblem zwischen \gls{ape} und \gls{github}, welches behoben werden muss. Erst dann kann der Vorgang fortgesetzt werden.

Nachfolgend kann der \lstinline!live! Branch mit \lstinline!git checkout live! ausgecheckt werden. Schlägt dies fehl, bedeutet das, dass der Branch noch nie ausgecheckt wurde. Um dies nachzuholen, muss der Branch explizit erstellt und mit dem Branch auf \gls{github} verknüpft werden: \lstinline!git checkout -b live origin/live!. Schließlich kann der Branch mit \lstinline!git pull origin live! auf den aktuellen Stand gebracht werden. Eine Zusammenfassung des Vorgangs ist in Listing \ref{lst:git_checkout_live} zu sehen.

\begin{figure}
	\begin{lstlisting}[caption=Wechsel auf den aktualisierten Deployment Branch,label={lst:git_checkout_live}]
	out = ssh.exec_in_path!(path, "git checkout live")
	if out =~ /error: pathspec 'live' did not match/
	  ssh.exec_in_path!(path, "git checkout -b live origin/live")
	end
	ssh.exec_in_path!(path, "git pull origin live")
	\end{lstlisting}
\end{figure}

Anschließend muss der Featurebranch in \lstinline!live! gemerged werden -- aber nur, wenn das Deployment vom Kunden über \gls{basecamp} ausgelöst wurde. Unternimmt ein Entwickler direkt einen \gls{pull request} in den \lstinline!live! Branch, ist der Merge bereits geschehen. Treten beim Merge Konflikte auf, müssen zwei Dinge passieren. Zum einen wird der Merge mit \lstinline!git reset --hard live! zurückgenommen und der Deployment-Vorgang abgebrochen. Zum anderen wird ein Entwickler benachrichtigt, dass er selbst mergen und die Konflikte beheben muss.

An diesem Punkt angekommen, befindet sich auf dem \gls{reposerver} exakt der Projektstand, der deployed werden soll. Nun müssen diese Daten lediglich übertragen werden, um den Vorgang abzuschließen. Dieses komplexe Thema wird separat in Kapitel \ref{ssub:uebertragung_der_dateien} besprochen.

% subsubsection staging_und_produktiv_deployment (end)

\subsubsection{Übertragung der Dateien} % (fold)
\label{ssub:uebertragung_der_dateien}

In diesem Kapitel wird das Übertragen der Dateien vom Git-Repository zum Zielsystem beschrieben. Je nach Serversetup sind verschiedene Übertragungsmechanismen notwendig. Im Moment kann ein Produkt über \gls{ftp}, sowie \gls{ssh} deployed werden.

Die Anforderung besteht darin, Dateien zu übertragen. Dabei bestimmen verschiedene Faktoren über die Güte des verwendeten Verfahrens. Es wird vorausgesetzt, dass alle Dateien fehlerfrei übertragen werden. Ein Verfahren gilt als besser, wenn es dieses Ziel in kürzerer Zeit als im verglichenen Verfahren erreicht. Weiterhin sind Systeme vorzuziehen, welche den Ausschluss einzelner Verzeichnisse aus der Übertragung zulassen. Diejenigen, welche nur zur Entwicklung benötigt werden, müssen nicht auf Zielsysteme übertragen werden.

\paragraph{Deployment mit SSH} % (fold)
\label{par:deployment_mit_ssh}

Ein Zugang über \gls{ssh} setzt voraus, dass ein Schlüsselpaar generiert und eingerichtet ist. Ist diese Voraussetzung erfüllt, gibt es aufgrund der Mächtigkeit des Protokolls verschiedene Möglichkeiten, das Produkt tatsächlich zu übertragen.

Es wird davon ausgegangen, dass alle Produkte mit Git verwaltet werden. Daher ist es denkbar, sich auf das Zielsystem per \gls{ssh} einzuloggen und dort im \Gls{deployment}-Pfad mit einem \lstinline!git pull! das Produkt zu aktualisieren. Dies setzt jedoch voraus, dass das Programm git auf allen Zielsystemen installiert ist. Die Konfiguration der einzelnen Server ist aber ungewiss und kann nicht immer beeinflusst werden. Daher wird auf diesen Ansatz verzichtet.

Stattdessen wird das Produkt mit \gls{rsync} übertragen. Rsync ist eine Anwendung, um Dateien und Verzeichnisse zwischen Servern zu synchronisieren. Durch die Verwendung von Delta Encoding\comment{externe referenz bietet sich an} ist der Vorgang zudem effizienter als bei einer normalen Dateiübertragung. Ein weiteres für diesen Anwendungsfall nützliches Feature ist die Möglichkeit, einzelne Verzeichnisse von der Übertragung auszuschließen. Auf den Zielsystemen wird nicht entwickelt, daher kann auf das .git Verzeichnis verzichtet werden. Ein Beispielbefehl ist in Listing \ref{lst:example_rsync} zu sehen.

Der Parameter \lstinline!-r! sorgt für eine rekursive Übertragung aller Verzeichnisse. Die Möglichkeit, über den \lstinline!--exclude! Parameter Verzeichnisse ausschließen zu können ist nicht notwendig, aber vorteilhaft. Das .git Verzeichnis beinhaltet tausende kleiner Dateien, welche den Übertragungsvorgang verlangsamen.

Insgesamt ist die Dateiübertragung mit rsync über \gls{ssh} zu bevorzugen. Mit dem einen in Listing \ref{lst:example_rsync} gezeigten Befehl werden alle Anforderungen erfüllt.

\begin{figure}
	\begin{lstlisting}[caption=Beispiel rsync Befehl,label={lst:example_rsync}]
	> rsync -r --exclude=.git \
		<lokaler-pfad> <user>@<host>:<entfernter-pfad>
	\end{lstlisting}
\end{figure}

% paragraph deployment_mit_ssh (end)

\paragraph{Deployment mit FTP} % (fold)
\label{par:deployment_mit_ftp}

Aus verschiedenen Gründen kann es sein, dass eine Übertragung der Dateien über SSH nicht möglich ist. Als alternative Option wird das File Transfer Protocol \gls{ftp} angeboten. Es werden zunächst die wesentlichen Einschränkungen und Nachteile des Protokolls formuliert:

Als erstes muss der Sicherheitsaspekt bedacht werden. Im Gegensatz zu \gls{ssh} geschieht die \gls{ftp}-Authentifizierung über Nutzername und Passwort. Da alle Vorgänge automatisiert stattfinden sollen, muss das \gls{ftp}-Passwort im Klartext in der Datenbank hinterlegt sein. Eine Verschlüsselung ist möglich, jedoch kein Hashing. Dieses wird sonst für Passwörter verwendet, um einen Rückschluss auf das Klartextpasswort zu verhindern. Darum muss darauf geachtet werden, dem \gls{ftp}-Nutzer nur die minimal nötigen Rechte einzuräumen.

Weiterhin verfügt das Protokoll nur über einen eingeschränkten Sprachschatz. Verzeichnisse können nicht rekursiv übertragen werden. Es können Dateien aus dem jeweils aktuellen Verzeichnis übertragen werden. Dabei ist es notwendig, dass sowohl lokal als auch auf dem Zielsystem in jedes Verzeichnis des Produkts gewechselt wird.

Da all das vollautomatisiert ablaufen muss, wurde im Rahmen dieser Arbeit ein Algorithmus entwickelt, welcher für ein gegebenes Projekt ein \gls{ftp}-Script zur Übertragung generiert. Zunächst wird mit Hilfe von find\comment{externe referenz bietet sich an} eine Liste aller Pfade ermittelt. Ein Beispiel ist in Listing \ref{lst:gen_path_list} zu sehen.

\begin{figure}
	\begin{lstlisting}[caption=Generiere Liste aller Pfade,label={lst:gen_path_list}]
	> find <path> -ls -path '*/.git*' -prune |\
		awk '{printf $3; for(x=11;x<=20;x++)\
		{printf " %s", $x} printf "\n" }'
	\end{lstlisting}
\end{figure}

Der \gls{find} Befehl schließt mit Hilfe der Parameter \lstinline!-path '*/.git*' -prune! das git Verzeichnis aus der Ergebnisliste aus. Außerdem wird mit \lstinline!-ls! eine detailliertere Ausgabe erzwungen, da die Information benötigt wird, ob ein gefundenes Objekt eine Datei oder ein Verzeichnis ist. Mit Hilfe von \gls{awk} wird die Ausgabe auf die Dateimodi, sowie den Pfad reduziert. Eine Beispielausgabe ist in Listing \ref{lst:gen_path_list_example} zu sehen.

\begin{figure}
	\begin{lstlisting}[caption=Beispielausgabe für gefundene Pfade,label={lst:gen_path_list_example}]
		drwxr-xr-x ./bar
		-rw-r--r-- ./bar/baz.rb
		-rw-r--r-- ./bar/foo.rb
		-rw-r--r-- ./impress.md
		-rw-r--r-- ./index.php
		-rw-r--r-- ./README
	\end{lstlisting}
\end{figure}
     
Anschließend wird anhand dieser Ausgabe eine Baumdatenstruktur erstellt, welche das Verzeichnis repräsentiert. Nun kann mit Hilfe des Visitor-Patterns\cite{designpatterns} das \gls{ftp}-Script generiert werden. Trifft der Visitor auf eine Datei, wird diese mit \lstinline!put <datei>! übertragen. Der Pseudocode zum Verarbeiten eines Verzeichnisses ist in Listing \ref{lst:process_dir} zu sehen.

Nachdem das Verzeichnis auf dem Zielsystem erstellt wurde, wird es sowohl lokal als auch im Ziel betreten. Anschließend werden rekursiv alle Kindknoten — also Dateien und eventuell weitere Verzeichnisse — übertragen. Schließlich wird das Verzeichnis wieder verlassen.

\begin{figure}
	\begin{lstlisting}[caption=Verarbeitung eines Verzeichnisses,label={lst:process_dir}]
		out = Array.new
		out << "mkdir <verzeichnisname>
		out << "lcd <verzeichnisname>
		out << "cd <verzeichnisname>
		for all children { out << child.receive }
		out << "lcd .."
		out << "cd .."
		return out
	\end{lstlisting}
\end{figure}

% paragraph deployment_mit_ftp (end)

\paragraph{Vergleich der Deployment Varianten} % (fold)
\label{ssub:vergleich_der_deployment_varianten}

Während über \gls{ssh} ein einziger rsync-Befehl ausreicht, um alle Anforderungen zu erreichen, muss für \gls{ftp} ein ganz eigener Algorithmus implementiert werden. Die \gls{ssh}-Authentifizierung ist sicher, da sie über ein Schlüsselpaar hergestellt wird. \gls{ftp} hingegen ist auf ein Klartext-Passwort angewiesen. Außerdem ist rsync schneller und damit effizienter als \gls{ftp}\comment{externe referenz bietet sich an}. Wenn die Auswahl besteht, sollte daher immer die \gls{ssh}-Variante vorgezogen werden.

% paragraph vergleich_der_deployment_varianten (end)

% subsubsection Übertragung_der_dateien (end)

% subsection implementierungsdetails (end)

% section sec:architektur_und_umsetzung (end)

\vfill

\section{Zusammenfassung und Ausblick} % (fold)
\label{sec:zusammenfassung_und_ausblick}

% - Was kann's? -> Highlights
APE senkt den Netzwerk- und Systemadministrationsaufwand. Die eingeführten Automatisierungen sparen allen Beteiligten Zeit. Jede automatisierte Aktion ist frei von Anfälligkeiten menschlicher Fehler. Der definierte Workflow hilft Entwicklern und Projektleitern, beliebig zwischen Projekten zu wechseln, wenn der Bedarf besteht. Kunden können über \gls{basecamp} transparent eingebunden werden.

% - Was wird in naher Zeit umgesetzt?
Zahlreiche Erweiterungen sind in Planung. Zum Beispiel ist eine Option für Hotfixes geplant, welche es erlaubt, direkt in das \gls{produktivsystem} zu deployen, um kritische Fehler mit weniger Schritten als für Features notwendig sind beheben zu können. Im Moment existiert eine rudimentäre Weboberfläche für die Konfiguration von \gls{ape}. Dort soll es in Zukunft möglich sein, den Status von Projekten zu überwachen. Die Daten liegen bereits vor, da sie für das Funktionieren des Services benötigt werden. Sie müssen lediglich noch in einer nützlichen Form visualisiert werden.

% - Was sind die Visionen?
Langfristig sind verschiedene größere Module denkbar. Zum Beispiel ist ein auf den Workflow angepasstes \gls{cli} auf \gls{git} wünschenswert. Dieses wird die Möglichkeit menschlicher Fehler weiter verringern.

Im Moment muss eine WordPress-Installation zu Beginn auf dem Server manuell eingerichtet werden und von diesem Zeitpunkt an wird nur noch innerhalb des \lstinline!wp-content! Ordners deployed. Es ist denkbar, dass \gls{ape} auch diese erste Installation mit übernimmt und auch Datenbankzugangsdaten, Domaineinstellungen usw. mit verwaltet.

% - evtl. Diskussion von Alternativen
Es ist auch denkbar, \gls{ape} als Plugin von \gls{jenkins}, einem existierenden \gls{CI} System, zu implementieren. Wenn eine Firma bereits \gls{ci} nutzt, wäre dies ein besserer Ansatz als \gls{ape} als eigenständigen Service laufen zu lassen. Doch bisher ist dies nicht geplant, daher gab es auch keine Veranlassung, dies in der Form umzusetzen.
% section zusammenfassung_und_ausblick (end)
