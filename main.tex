\section{Einleitung} % (fold)
\label{sec:einleitung}

Das Projekt entsteht im Auftrag der Agentur \gls{inps}. Diese erhofft sich Kosteinersparnis durch Automatisierung, sowie eine solidere rechtliche Basis gegenüber ihren Kunden.

Automatisierung wird an verschiedenen Stellen eingeführt. Da bereits das Versionskontrollsystem git verwendet wird, werden dessein Eigenschaften ausgenutzt. Hält ein Entwickler ein Feature für abgeschlossen, stellt er über den Service GitHub einen so genannten Pull Request. Alle am Projekt beteiligten Entwickler werden benachrichtigt und können Anmerkungen und sogar Änderungen vornehmen, bevor das Feature gemerged wird. Dies geschieht automatisch. Außerdem wird im Projektmanagement-Tool Basecamp eine zum Pull Request passende ToDo erstellt. Der Kunde wird außerdem per E-Mail benachrichtigt.

Letztgenannter Part ist insbesondere rechtlich interessant. Der Kunde kann das Feature nun in einer separaten Testumgebung ansehen und eventuell von seiner eigenen \gls{qa}-Abteilung verifizieren lassen. Ist der Kunde zufrieden, hakt er die ToDo ab und gibt damit sein Einverständnis. Es kann vertraglich geregelt werden, dass der Kunde sich der Qualität des Features versichert hat und somit die \gls{inps} keinerlei Kosten für eventuell auf diesem Feature basierenden Ausfällen übernimmt.

Die Bestätigung des Kunden löst einen weiteren Automatisierungsmechanismus auf. Das Feature wird in den produktiven Versionierungszweig gemerged und sofort auf das Produktivsystem deployed. Der Entwickler muss nichts weiter unternehmen und der Kunde kann sein akzeptiertes Feature ohne Verzögerung betrachten.

Insgesamt wird ein Service entwickelt, welcher die bereits genutzten Systeme GitHub und Basecamp verbindet und einige Automatisierungen durchführt. Die Integration ist dabei transparent. Weder Kunde noch Entwickler sieht jemals eine grafische Oberfläche des Services. Beide Parteien profitieren jedoch von den Automatisierungen und Absicherungen, welche der Service bietet.

% section einleitung (end)

\section{Technologien und Konzepte} % (fold) 8+ Seiten, Allgemeines Kapitel
\label{sec:technologien_und_konzepte}

% - Deployment = …
% - Aufwand des Deployments senken durch Automatisierung
% - mehr Automatisierung -> weniger Fehleranfällig, da keine Flüchtigkeitsfehler auftreten können
% - Kleinere Iterationszyklen ermöglichen
% - gesteigerte Kundenintegration für Vertrauen und Sicherheit
% - Ergänzung zu Continuous Integration

% section technologien_und_konzepte (end)

\section{Architektur und Umsetzung} % (fold) 10+ Seiten
\label{sec:architektur_und_umsetzung}

Das folgende Kapitel erläutert die Details des entstandenen Services. Zunächst wird erläutert, welches Problem \gls{ape} löst und weshalb genau dieser und kein anderer Ansatz gewählt wird. Anschließend werden Konzept und Architektur des Services analysiert, sowie einzelne Kernelemente der Software im Detail besprochen.

\subsection{Ziel des Services} % (fold)
\label{sub:ziel_des_services}

%% Welches Problem wird gelöst
\gls{ape} wird speziell für die Firma \gls{inps} entwickelt. Daher ist es zum Verständnis des Problems notwendig, eine Vorstellung von deren Dienstleistungen und Arbeitsabläufen zu haben.

\subsubsection{\gls{inps}} % (fold)
\label{ssub:inps}

% subsubsection inps (end)

Die \gls{inps} ist eine deutsche \gls{wp}-Agentur. Sie nimmt Aufträge von Kunden aller Größe an, um ihre Webseitenwünsche im \gls{cms} \gls{wp} umzusetzen. Die Auftragsbreite reicht von kleinen Pluginentwicklungen bis hin zur Konzeption und Umsetzung ganzer Blognetzwerke und Shopsysteme.

Ihre Mitarbeiter befinden sich verteilt in Mitteleuropa und arbeiten vorwiegend von zuhause. Damit arbeitet die \gls{inps} dezentral. Um je nach Auftragslage flexibel handeln zu können, werden mehr freie als fest angestellte Mitarbeiter beschäftigt.

An den kleinsten Projekten arbeiten einzelne Mitarbeiter, aber an der Mehrheit der Projekte arbeiten zwei oder mehr. Es gibt Projektleiter, welche Arbeit an die Entwickler verteilen und den größtmöglichen Teil der Kommunikation mit den Kunden übernehmen, damit die Entwickler ungestört arbeiten können. Dies sind die wesentlichen Rollen im Arbeitsfluss: Projektleiter, Entwickler und Kunde.

Der optimale Informationsfluss (Abbildung~\ref{fig:ideale-beziehung}) ist jedoch unrealistisch. Spätestens wenn das Projekt in Betrieb ist und Fehler berichtet werden, ist die Projektleiter-Schicht zum Teil eine unnötige Barriere. Um dennoch zu gewährleisten, dass der Kunde den Entwickler nicht direkt mit E-Mails oder Anrufen stört, wird das Projekt-Management Tool \Gls{basecamp} benutzt. Dort werden Fehlerberichte, sowie Featureanfragen in To-do-Listen verwaltet (Abbildung~\ref{fig:tatsaechliche-beziehung}).

Im Folgenden wird nicht mehr zwischen Fehlerbericht und Featureanfrage unterschieden werden. Aus Sicht des Arbeitsablaufs gibt es keinen Unterschied, daher ist es unnötig, beide Fälle zu betrachten. Es wird nur noch von Features die Rede sein.

\begin{figure}
	\begin{tikzpicture}[auto]
		\node (pm) {Projektleiter};
		\node (customer) [left=of pm] {Kunde}
			edge [<->] (pm)
		;
		\node (dev) [right=of pm] {Entwickler}
			edge [<->] (pm)
		;
	\end{tikzpicture}
	\caption{Optimaler Informationsfluss}
	\label{fig:ideale-beziehung}
\end{figure}

\begin{figure}
	\begin{tikzpicture}[auto]
		\node (center) {};
		\node (customer)	[left=of center]	{Kunde};
		\node (dev) 		[right=of center]	{Entwickler};
		\node (bc)			[above=of center]	{Basecamp}
			edge [<->,bend right] (customer)
			edge [<->,bend left] (dev)
		;
		\node (pm)			[below=of center]	{Projektleiter}
			edge [<->,bend left] (customer)
			edge [<->,bend right] (dev)
		;
	\end{tikzpicture}
	\caption{Tatsächlicher Informationsfluss}
	\label{fig:tatsaechliche-beziehung}
\end{figure}

\subsubsection{Entwicklung eines Features} % (fold)
\label{ssub:entwicklung_eines_features}

Abhängig vom Projekt unterscheiden gibt es Abweichungen vom Arbeitsablauf. Doch die prinzipielle Vorgehensweise ist immer die gleiche. Diese wird nun beschrieben.

Der Kunde formuliert die Spezifikation für ein Feature oder eine Menge von Features. Diese werden vom Projekleiter begutachtet und eventuelle Unklarheiten werden im Dialog mit dem Kunden beseitigt. Ist das Projekt bereits fortgeschritten, formuliert der Kunde seine Wünsche direkt im Basecamp. Erfahrungsgemäß sind dies dann nur noch Anpassungen und Fehlerberichte, so dass der Projektleiter nicht mehr jede Anfrage kontrollieren muss.

Ein Entwickler weist sich eigenverantwortlich eine Teilaufgabe zu und beginnt, diese zu bearbeiten. Dazu stellt er sicher, dass er lokal die aktuelle Variante des Projekts vorliegen hat und beginnt, das Feature umzusetzen. Im Moment ist es dem Entwickler überlassen, ob er in separaten Branches arbeitet oder nicht. Sind mehrere Entwickler an einem Projekt beteiligt, sollen diese sich lediglich auf eine Vorgehensweise einigen.

Ist das Feature fertig entwickelt, werden die Änderungen manuell in ein Testsystem übertragen und der Kunde benachrichtigt. Der Kommunikationskanal ist dabei wieder projektabhängig. Ist der Kunde zufrieden, muss das Feature manuell auf das Produktivsystem übertragen werden.

Da der Vorgang insgesamt sehr aufwändig ist, wird vorwiegend in Releases gearbeitet. Das heißt, dass einige Tage oder Wochen Features entwickelt und in unregelmäßigen Abständen auf das Testsystem übertragen werden. An einem definierten Datum gibt es einen \gls{feature_freeze}. Einen Tag lang wird nur noch an der Stabilität des Releases gearbeitet und der Release selbst vorbereitet und durchgeführt. Verläuft dieser erfolgreich, beginnt der Zyklus erneut.

Diese Vorgehensweise funktioniert, ist jedoch umständlicher als sie sein müsste. Die Webplattform ist prädestiniert für tägliche oder mehrmals tägliche Releases. Es muss lediglich ein passender Workflow gefunden werden.

Weiterhin besteht im Moment das Problem, dass zwischen Projekten Unterschiede herrschen, die zwar klein aber doch vorhanden sind. Das sorgt dafür, dass Entwickler nicht konfliktfrei zwischen Projekten wechseln können. Es ist immer mit Verwirrung und Absprachen verbunden, die bei geeigneten Konventionen nicht nötig wären.

Dieses Problem soll \gls{ape} lösen. Es ist ein Workflow zu entferfen, welcher Konventionen einführt, der die oben genannten Abläufe vereinheitlicht. Automatisierungen sind, wo möglich, mit Hilfe der Software umzusetzen.

% subsubsection entwicklung_eines_features (end)

\subsection{Einheitlicher Workflow} % (fold)
\label{sub:einheitlicher_workflow}

Zunächst wird festgelegt, dass jedes Feature in seinem eigenen \gls{git}-Branch entwickelt wird. Das hat mehrere Vorteile. Entwickler in einem Projekt müssen sich weniger absprechen, da jeder in seinem eigenen Branch arbeitet. Ein Entwickler kann bei Prioritätenverschiebung zudem sofort die Arbeit an einem Feature anhalten und in einem parallelen Branch das wichtigere Feature bearbeiten. Auf Codeebene lässt sich mit einem einzigen \gls{git}-Befehl ermitteln, welche Zeilen das Feature verändert.

Weiterhin werden \gls{github} \glspl{pull request} ein fester Bestandteil des Workflows. Dies sind automatisierte Anträge, einen Branch in einen anderen zu mergen. Ein \gls{pull request} zeigt die Versionshistorie des Features und die Summe aller Änderungen. Andere Entwickler können das Feature reviewen, Anmerkungen hinterlassen und selbst Änderungen am Feature vornehmen. Sind alle Entwickler mit der Codequalität zufrieden, wird der \gls{pull request} akzeptiert und \gls{github} merged die Branches automatisch.

Ein \gls{pull request} wird vom Entwickler genau dann erstellt, wenn er mit der Entwicklung eines Features fertig ist und dieses bereit für das Staging-System ist. Wird dieser akzeptiert, sollen automatisch zwei Aktionen geschehen. Zum Einen muss das Feature auf dem Staging-System verfügbar werden. Zum Anderen soll der Kunde benachrichtigt werden, dass dieses Feature nun bereit zum testen ist. Beide Aufgaben werden vom \gls{ape} übernommen.

Das \gls{ape}-System wird von GitHub per \Gls{webhook} informiert, dass ein Pull Request akzeptiert wurde. Zuerst wird das Staging-System aktualisiert. Dazu müssen lediglich die Dateien aus dem Staging-Branch übertragen werden, da \gls{github} bereits das Mergen der Branches übernommen hat. Anschließend wird über eine API in \gls{basecamp} ein To-do angelegt, welches den Kunden über das Feature im Testsystem informiert und und um Feedback bittet. Basecamp verschickt automatisch eine E-Mail an den Kunden, so dass zwischen Akzeptanz des \glspl{pull request} und der automatischen Benachrichtigung des Kunden lediglich Sekunden oder Minuten liegen.

Gibt es Probleme, kann der Kunde diese über das Kommentarsystem in \gls{basecamp} äußern und der Entwickler kann diese bearbeiten. Ist der Kunde sofort oder nach Behebung aller Probleme zufrieden, kennzeichnet er dies durch das Abhaken der To-do. \gls{ape} registriert die Veränderung des Status der To-do automatisch und beginnt, das Feature auf das Produktivsystem zu übertragen. Dazu merged er selbstständig den Featurebranch in den Produktivbranch und überträgt das Ergebnis auf das Produktivsystem.

Damit ist ein Featurezyklus abgeschlossen. Ist das Feature klein (z.B. nur eine Codezeile muss angepasst werden) und reagieren alle Parteien schnell, kann der gesamte Zyklus einschließlich Programmierung in weniger als 15 Minuten abgearbeitet werden. Damit können selbst kritische Änderungen schnell vorgenommen werden. Es können beliebig viele dieser Zyklen parallel aktiv sein und ein Entwickler kann an verschiedenen Features gleichzeitig arbeiten, ohne dass sich deren Entwicklungsweige behindern.

% subsection einheitlicher_workflow (end)

%% Wie wird es gelöst
%% Warum wird es so gelöst
%% Warum nicht anders

%% Architektur

% subsection ziel_des_services (end)

% - TODO Begründung der Herangehensweise
% - TODO …

\subsection{Übertragung der Dateien} % (fold)
\label{sub:Übertragung_der_dateien}

Im Folgenden wird das Übertragen der Dateien vom Git-Repository zum Zielsystem beschrieben. Je nach Serversetup sind verschiedene Übertragungsmechanismen notwendig. Im Moment kann ein Produkt über \gls{ftp}, sowie \gls{ssh} deployed werden.

Die Anforderung besteht darin, Dateien zu übertragen. Dabei bestimmen verschiedene Faktoren über die Güte des verwendeten Verfahrens. Es wird vorausgesetzt, dass alle Dateien fehlerfrei übertragen werden. Ein Verfahren gilt als besser, wenn es dieses Ziel in kürzerer Zeit erreichen kann. Weiterhin sind Systeme vorzuziehen, welche den Ausschluss einzelner Verzeichnisse aus der Übertragung zulassen. Diejenigen, welche nur zur Entwicklung benötigt werden, müssen nicht auf Zielsysteme übertragen werden.

\subsubsection{Deployment mit SSH} % (fold)
\label{ssub:deployment_mit_ssh}

Ein Zugang über \gls{ssh} setzt voraus, dass ein Schlüsselpaar generiert und eingerichtet ist. Ist diese Voraussetzung erfüllt, gibt es aufgrund der Mächtigkeit des Protokolls verschiedene Möglichkeiten, das Produkt tatsächlich zu übertragen.

Es wird davon ausgegangen, dass alle Produkte mit Git verwaltet werden. Daher ist es denkbar, sich auf das Zielsystem per \gls{ssh} einzuloggen und dort im \Gls{deployment}-Pfad mit einem \lstinline!git pull! das Produkt zu aktualisieren. Dies setzt jedoch voraus, dass das Programm git auf allen Zielsystemen installiert ist. Die Konfiguration der einzelnen Server ist aber ungewiss und kann nicht immer beeinflusst werden. Daher wird auf diesen Ansatz verzichtet.

Stattdessen wird das Produkt mit rsync\comment{externe referenz bietet sich an} übertragen. Rsync ist eine Anwendung, um Dateien und Verzeichnisse zwischen Servern zu synchronisieren. Durch die Verwendung von Delta Encoding\comment{externe referenz bietet sich an} ist der Vorgang zudem effizienter als bei einer normalen Dateiübertragung. Ein weiteres für diesen Anwendungsfall nützliches Feature ist die Möglichkeit, einzelne Verzeichnisse von der Übertragung auszuschließen. Auf den Zielsystemen wird nicht entwickelt, daher kann auf das .git Verzeichnis verzichtet werden. Ein Aufruf sieht beispielhaft wie folgt\comment{LaTeX-Referenz draus machen} aus:

> rsync -r --exclude=.git <lokaler-pfad> <user>@<host>:<entfernter-pfad>

Der Parameter \lstinline!-r! sorgt für eine rekursive Übertragung aller Verzeichnisse. Die Möglichkeit, über den \lstinline!--exclude! Parameter Verzeichnisse ausschließen zu können ist nicht notwendig, aber vorteilhaft. Das .git Verzeichnis beinhaltet tausende kleiner Dateien, welche den Übertragungsvorgang verlangsamen würden.

Insgesamt ist die Dateiübertragung mit rsync über \gls{ssh} zu bevorzugen. Mit dem einen oben genannten Befehl\comment{LaTeX-Referenz draus machen} werden alle Anforderungen erfüllt.

% subsubsection deployment_mit_ssh (end)

\subsubsection{Deployment mit FTP} % (fold)
\label{ssub:deployment_mit_ftp}

Aus verschiedenen Gründen kann es sein, dass eine Übertragung der Dateien über \textbf{SSH} nicht möglich ist. Als alternative Option wird das File Transfer Protocol \gls{ftp} angeboten. Im Folgenden werden zunächst die wesentlichen Einschränkungen und Nachteile des Protokolls formuliert.

Als erstes muss der Sicherheitsaspekt bedacht werden. Im Gegensatz zu \gls{ssh} geschieht die \gls{ftp}-Authentifizierung über Nutzername und Passwort. Da alle Vorgänge automatisiert stattfinden sollen, muss das \gls{ftp}-Passwort im Klartext in der Datenbank hinterlegt sein. Eine Verschlüsselung ist möglich, jedoch kein Hashing. Dieses wird sonst für Passwörter verwendet, um einen Rückschluss auf das Klartextpasswort zu verhindern. Darum muss darauf geachtet werden, dem \gls{ftp}-Nutzer nur die minimal nötigen Rechte einzuräumen.

Weiterhin verfügt das Protokoll nur über einen eingeschränkten Sprachschatz. Verzeichnisse können nicht rekursiv übertragen werden. Es können Dateien aus dem jeweils aktuellen Verzeichnis übertragen werden. Dabei ist es notwendig, dass sowohl lokal als auch auf dem Zielsystem in jedes Verzeichnis des Produkts gewechselt wird.

Da all das vollautomatisiert ablaufen muss, wurde ein Algorithmus entwickelt, welcher für ein gegebenes Projekt ein \gls{ftp}-Script zur Übertragung generiert. Zunächst wird mit Hilfe von find\comment{externe referenz bietet sich an} eine Liste aller Pfade ermittelt. Ein Beispiel ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
> find <path> -ls -path '*/.git*' -prune |\
	awk '{printf $3; for(x=11;x<=20;x++)\
	{printf " %s", $x} printf "\n" }'
\end{lstlisting}

Der find\comment{externe referenz bietet sich an} Befehl schließt mit Hilfe der Parameter \lstinline!-path '*/.git*' -prune! das git Verzeichnis aus der Ergebnisliste aus. Außerdem wird mit \lstinline!-ls! eine detailliertere Ausgabe erzwungen, da die Information benötigt wird, ob ein gefundenes Objekt eine Datei oder ein Verzeichnis ist. Mit Hilfe von awk\comment{externe referenz bietet sich an} wird die Ausgabe auf die Dateimodi, sowie den Pfad reduziert. Eine Beispielausgabe ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
	drwxr-xr-x ./bar
	-rw-r--r-- ./bar/baz.rb
	-rw-r--r-- ./bar/foo.rb
	-rw-r--r-- ./impress.md
	-rw-r--r-- ./index.php
	-rw-r--r-- ./README
\end{lstlisting}
     
Anschließend wird anhand dieser Ausgabe eine Baumdatenstruktur erstellt, welche das Verzeichnis repräsentiert. Nun kann mit Hilfe des Visitor-Patterns\comment{externe referenz bietet sich an} das \gls{ftp}-Script generiert werden. Trifft der Visitor auf eine Datei, wird diese mit \lstinline!put <datei>! übertragen. Der Pseudocode zum Verarbeiten eines Verzeichnisses ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
	out = Array.new
	out << "mkdir <verzeichnisname>
	out << "lcd <verzeichnisname>
	out << "cd <verzeichnisname>
	for all children { out << child.receive }
	out << "lcd .."
	out << "cd .."
	return out
\end{lstlisting}

Nachdem das Verzeichnis auf dem Zielsystem erstellt wurde, wird es sowohl lokal als auch im Ziel betreten. Anschließend werden rekursiv alle Kindknoten — also Dateien und eventuell weitere Verzeichnisse — abgearbeitet. Schließlich wird das Verzeichnis wieder verlassen.

% subsubsection deployment_mit_ftp (end)

\subsubsection{Vergleich der Deployment Varianten} % (fold)
\label{ssub:vergleich_der_deployment_varianten}

Während über \gls{ssh} ein einziger rsync-Befehl ausreicht, um alle Andforderungen zu erreichen, muss für \gls{ftp} ein ganz eigener Algorithmus implementiert werden. Die \gls{ssh}-Authentifizierung ist sicher, da sie über ein Schlüsselpaar hergestellt wird. \gls{ftp} hingegen ist auf ein Klartext-Passwort angewiesen. Außerdem ist rsync schneller und damit effizienter als \gls{ftp}\comment{externe referenz bietet sich an}. Wenn die Auswahl besteht, sollte daher immer die \gls{ssh}-Variante vorgezogen werden.

% subsubsection vergleich_der_deployment_varianten (end)

% subsection Übertragung_der_dateien (end)

% section sec:architektur_und_umsetzung (end)

\section{Zusammenfassung und Ausblick} % (fold)
\label{sec:zusammenfassung_und_ausblick}
% - Was kann's? -> Highlights
% - Was wird in naher Zeit umgesetzt?
% - Was sind die Visionen?
% - evtl. Diskussion von Alternativen
% section zusammenfassung_und_ausblick (end)
