\section{Einleitung} % (fold)
\label{sec:einleitung}

Das Projekt entsteht im Auftrag der Agentur \gls{inps}. Diese erhofft sich Kosteinersparnis durch Automatisierung, sowie eine solidere rechtliche Basis gegenüber ihren Kunden.

Automatisierung wird an verschiedenen Stellen eingeführt. Da bereits das Versionskontrollsystem git verwendet wird, werden dessein Eigenschaften ausgenutzt. Hält ein Entwickler ein Feature für abgeschlossen, stellt er über den Service GitHub einen so genannten Pull Request. Alle am Projekt beteiligten Entwickler werden benachrichtigt und können Anmerkungen und sogar Änderungen vornehmen, bevor das Feature gemerged wird. Dies geschieht automatisch. Außerdem wird im Projektmanagement-Tool Basecamp eine zum Pull Request passende ToDo erstellt. Der Kunde wird außerdem per E-Mail benachrichtigt.

Letztgenannter Part ist insbesondere rechtlich interessant. Der Kunde kann das Feature nun in einer separaten Testumgebung ansehen und eventuell von seiner eigenen \gls{qa}-Abteilung verifizieren lassen. Ist der Kunde zufrieden, hakt er die ToDo ab und gibt damit sein Einverständnis. Es kann vertraglich geregelt werden, dass der Kunde sich der Qualität des Features versichert hat und somit die \gls{inps} keinerlei Kosten für eventuell auf diesem Feature basierenden Ausfällen übernimmt.

Die Bestätigung des Kunden löst einen weiteren Automatisierungsmechanismus auf. Das Feature wird in den produktiven Versionierungszweig gemerged und sofort auf das Produktivsystem deployed. Der Entwickler muss nichts weiter unternehmen und der Kunde kann sein akzeptiertes Feature ohne Verzögerung betrachten.

Insgesamt wird ein Service entwickelt, welcher die bereits genutzten Systeme GitHub und Basecamp verbindet und einige Automatisierungen durchführt. Die Integration ist dabei transparent. Weder Kunde noch Entwickler sieht jemals eine grafische Oberfläche des Services. Beide Parteien profitieren jedoch von den Automatisierungen und Absicherungen, welche der Service bietet.

% section einleitung (end)

\section{Technologien und Konzepte} % (fold) 8+ Seiten, Allgemeines Kapitel
\label{sec:technologien_und_konzepte}

% - Deployment = …
% - Aufwand des Deployments senken durch Automatisierung
% - mehr Automatisierung -> weniger Fehleranfällig, da keine Flüchtigkeitsfehler auftreten können
% - Kleinere Iterationszyklen ermöglichen
% - gesteigerte Kundenintegration für Vertrauen und Sicherheit
% - Ergänzung zu Continuous Integration

% section technologien_und_konzepte (end)

\section{Architektur und Umsetzung} % (fold) 10+ Seiten
\label{sec:architektur_und_umsetzung}

Das folgende Kapitel erläutert die Details des entstandenen Services. Zunächst wird erläutert, welches Problem \gls{ape} löst und weshalb genau dieser und kein anderer Ansatz gewählt wird. Anschließend werden Konzept und Architektur des Services analysiert, sowie einzelne Kernelemente der Software im Detail besprochen.

\subsection{Ziel des Services} % (fold)
\label{sub:ziel_des_services}

%% Welches Problem wird gelöst
\gls{ape} wird speziell für die Firma \gls{inps} entwickelt. Daher ist es zum Verständnis des Problems notwendig, eine Vorstellung von deren Dienstleistungen und Arbeitsabläufen zu haben.

Die \gls{inps} ist eine deutsche \gls{wp}-Agentur. Sie nimmt Aufträge von Kunden aller Größe an, um ihre Webseitenwünsche im \gls{cms} \gls{wp} umzusetzen. Die Auftragsbreite reicht von kleinen Pluginentwicklungen bis hin zur Konzeption und Umsetzung ganzer Blognetzwerke und Shopsystemen.

Ihre Mitarbeiter befinden sich verteilt in Mitteleuropa und arbeiten vorwiegend von zuhause. Damit arbeitet die \gls{inps} dezentral. Um je nach Auftragslage flexibel handeln zu können, werden mehr freie als fest angestellte Mitarbeiter beschäftigt.

An den kleinsten Projekten arbeiten einzelne Mitarbeiter, aber an der Mehrheit der Projekte arbeiten zwei oder mehr. Es gibt Projektleiter, welche Arbeit an die Entwickler verteilen und den größtmöglichen Teil der Kommunikation mit den Kunden übernehmen, damit die Entwickler ungestört arbeiten können. Dies sind die wesentlichen Rollen im Arbeitsfluss: Projektleiter, Entwickler und Kunde.

Der optimale Informationsfluss (Abbildung~\ref{fig:ideale-beziehung}) ist jedoch unrealistisch. Spätestens wenn das Projekt in Betrieb ist und Fehler berichtet werden, ist die Projektleiter-Schicht zum Teil eine unnötige Barriere. Um dennoch zu gewährleisten, dass der Kunde den Entwickler nicht direkt mit E-Mails oder Anrufen stört, wird das Projekt-Management Tool \Gls{basecamp} benutzt. Dort werden Fehlerberichte, sowie Featureanfragen in To-do-Listen verwaltet (Abbildung~\ref{fig:tatsaechliche-beziehung}).

Im Folgenden wird nicht mehr zwischen Fehlerbericht und Featureanfrage unterschieden werden. Aus Sicht des Arbeitsablaufs gibt es keinen Unterschied, daher ist es unnötig, beide Fälle zu betrachten. Es wird nur noch von Features die Rede sein.

\begin{figure}
	\begin{tikzpicture}[auto]
		\node (pm) {Projektleiter};
		\node (customer) [left=of pm] {Kunde}
			edge [<->] (pm)
		;
		\node (dev) [right=of pm] {Entwickler}
			edge [<->] (pm)
		;
	\end{tikzpicture}
	\caption{Optimaler Informationsfluss}
	\label{fig:ideale-beziehung}
\end{figure}

\begin{figure}
	\begin{tikzpicture}[auto]
		\node (center) {};
		\node (customer)	[left=of center]	{Kunde};
		\node (dev) 		[right=of center]	{Entwickler};
		\node (bc)			[above=of center]	{Basecamp}
			edge [<->,bend right] (customer)
			edge [<->,bend left] (dev)
		;
		\node (pm)			[below=of center]	{Projektleiter}
			edge [<->,bend left] (customer)
			edge [<->,bend right] (dev)
		;
	\end{tikzpicture}
	\caption{Tatsächlicher Informationsfluss}
	\label{fig:tatsaechliche-beziehung}
\end{figure}


%% Wie wird es gelöst
%% Warum wird es so gelöst
%% Warum nicht anders

%% Architektur

% subsection ziel_des_services (end)

% - TODO Begründung der Herangehensweise
% - TODO …

\subsection{Übertragung der Dateien} % (fold)
\label{sub:Übertragung_der_dateien}

Im Folgenden wird das Übertragen der Dateien vom Git-Repository zum Zielsystem beschrieben. Je nach Serversetup sind verschiedene Übertragungsmechanismen notwendig. Im Moment kann ein Produkt über \gls{ftp}, sowie \gls{ssh} deployed werden.

Die Anforderung besteht darin, Dateien zu übertragen. Dabei bestimmen verschiedene Faktoren über die Güte des verwendeten Verfahrens. Es wird vorausgesetzt, dass alle Dateien fehlerfrei übertragen werden. Ein Verfahren gilt als besser, wenn es dieses Ziel in kürzerer Zeit erreichen kann. Weiterhin sind Systeme vorzuziehen, welche den Ausschluss einzelner Verzeichnisse aus der Übertragung zulassen. Diejenigen, welche nur zur Entwicklung benötigt werden, müssen nicht auf Zielsysteme übertragen werden.

\subsubsection{Deployment mit SSH} % (fold)
\label{ssub:deployment_mit_ssh}

Ein Zugang über \gls{ssh} setzt voraus, dass ein Schlüsselpaar generiert und eingerichtet ist. Ist diese Voraussetzung erfüllt, gibt es aufgrund der Mächtigkeit des Protokolls verschiedene Möglichkeiten, das Produkt tatsächlich zu übertragen.

Es wird davon ausgegangen, dass alle Produkte mit Git verwaltet werden. Daher ist es denkbar, sich auf das Zielsystem per \gls{ssh} einzuloggen und dort im \Gls{deployment}-Pfad mit einem \lstinline!git pull! das Produkt zu aktualisieren. Dies setzt jedoch voraus, dass das Programm git auf allen Zielsystemen installiert ist. Die Konfiguration der einzelnen Server ist aber ungewiss und kann nicht immer beeinflusst werden. Daher wird auf diesen Ansatz verzichtet.

Stattdessen wird das Produkt mit rsync\comment{externe referenz bietet sich an} übertragen. Rsync ist eine Anwendung, um Dateien und Verzeichnisse zwischen Servern zu synchronisieren. Durch die Verwendung von Delta Encoding\comment{externe referenz bietet sich an} ist der Vorgang zudem effizienter als bei einer normalen Dateiübertragung. Ein weiteres für diesen Anwendungsfall nützliches Feature ist die Möglichkeit, einzelne Verzeichnisse von der Übertragung auszuschließen. Auf den Zielsystemen wird nicht entwickelt, daher kann auf das .git Verzeichnis verzichtet werden. Ein Aufruf sieht beispielhaft wie folgt\comment{LaTeX-Referenz draus machen} aus:

> rsync -r --exclude=.git <lokaler-pfad> <user>@<host>:<entfernter-pfad>

Der Parameter \lstinline!-r! sorgt für eine rekursive Übertragung aller Verzeichnisse. Die Möglichkeit, über den \lstinline!--exclude! Parameter Verzeichnisse ausschließen zu können ist nicht notwendig, aber vorteilhaft. Das .git Verzeichnis beinhaltet tausende kleiner Dateien, welche den Übertragungsvorgang verlangsamen würden.

Insgesamt ist die Dateiübertragung mit rsync über \gls{ssh} zu bevorzugen. Mit dem einen oben genannten Befehl\comment{LaTeX-Referenz draus machen} werden alle Anforderungen erfüllt.

% subsubsection deployment_mit_ssh (end)

\subsubsection{Deployment mit FTP} % (fold)
\label{ssub:deployment_mit_ftp}

Aus verschiedenen Gründen kann es sein, dass eine Übertragung der Dateien über \textbf{SSH} nicht möglich ist. Als alternative Option wird das File Transfer Protocol \gls{ftp} angeboten. Im Folgenden werden zunächst die wesentlichen Einschränkungen und Nachteile des Protokolls formuliert.

Als erstes muss der Sicherheitsaspekt bedacht werden. Im Gegensatz zu \gls{ssh} geschieht die \gls{ftp}-Authentifizierung über Nutzername und Passwort. Da alle Vorgänge automatisiert stattfinden sollen, muss das \gls{ftp}-Passwort im Klartext in der Datenbank hinterlegt sein. Eine Verschlüsselung ist möglich, jedoch kein Hashing. Dieses wird sonst für Passwörter verwendet, um einen Rückschluss auf das Klartextpasswort zu verhindern. Darum muss darauf geachtet werden, dem \gls{ftp}-Nutzer nur die minimal nötigen Rechte einzuräumen.

Weiterhin verfügt das Protokoll nur über einen eingeschränkten Sprachschatz. Verzeichnisse können nicht rekursiv übertragen werden. Es können Dateien aus dem jeweils aktuellen Verzeichnis übertragen werden. Dabei ist es notwendig, dass sowohl lokal als auch auf dem Zielsystem in jedes Verzeichnis des Produkts gewechselt wird.

Da all das vollautomatisiert ablaufen muss, wurde ein Algorithmus entwickelt, welcher für ein gegebenes Projekt ein \gls{ftp}-Script zur Übertragung generiert. Zunächst wird mit Hilfe von find\comment{externe referenz bietet sich an} eine Liste aller Pfade ermittelt. Ein Beispiel ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
> find <path> -ls -path '*/.git*' -prune |\
	awk '{printf $3; for(x=11;x<=20;x++)\
	{printf " %s", $x} printf "\n" }'
\end{lstlisting}

Der find\comment{externe referenz bietet sich an} Befehl schließt mit Hilfe der Parameter \lstinline!-path '*/.git*' -prune! das git Verzeichnis aus der Ergebnisliste aus. Außerdem wird mit \lstinline!-ls! eine detailliertere Ausgabe erzwungen, da die Information benötigt wird, ob ein gefundenes Objekt eine Datei oder ein Verzeichnis ist. Mit Hilfe von awk\comment{externe referenz bietet sich an} wird die Ausgabe auf die Dateimodi, sowie den Pfad reduziert. Eine Beispielausgabe ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
	drwxr-xr-x ./bar
	-rw-r--r-- ./bar/baz.rb
	-rw-r--r-- ./bar/foo.rb
	-rw-r--r-- ./impress.md
	-rw-r--r-- ./index.php
	-rw-r--r-- ./README
\end{lstlisting}
     
Anschließend wird anhand dieser Ausgabe eine Baumdatenstruktur erstellt, welche das Verzeichnis repräsentiert. Nun kann mit Hilfe des Visitor-Patterns\comment{externe referenz bietet sich an} das \gls{ftp}-Script generiert werden. Trifft der Visitor auf eine Datei, wird diese mit \lstinline!put <datei>! übertragen. Der Pseudocode zum Verarbeiten eines Verzeichnisses ist in Listing \comment{LaTeX-Referenz draus machen} zu sehen.

\begin{lstlisting}
	out = Array.new
	out << "mkdir <verzeichnisname>
	out << "lcd <verzeichnisname>
	out << "cd <verzeichnisname>
	for all children { out << child.receive }
	out << "lcd .."
	out << "cd .."
	return out
\end{lstlisting}

Nachdem das Verzeichnis auf dem Zielsystem erstellt wurde, wird es sowohl lokal als auch im Ziel betreten. Anschließend werden rekursiv alle Kindknoten — also Dateien und eventuell weitere Verzeichnisse — abgearbeitet. Schließlich wird das Verzeichnis wieder verlassen.

% subsubsection deployment_mit_ftp (end)

\subsubsection{Vergleich der Deployment Varianten} % (fold)
\label{ssub:vergleich_der_deployment_varianten}

Während über \gls{ssh} ein einziger rsync-Befehl ausreicht, um alle Andforderungen zu erreichen, muss für \gls{ftp} ein ganz eigener Algorithmus implementiert werden. Die \gls{ssh}-Authentifizierung ist sicher, da sie über ein Schlüsselpaar hergestellt wird. \gls{ftp} hingegen ist auf ein Klartext-Passwort angewiesen. Außerdem ist rsync schneller und damit effizienter als \gls{ftp}\comment{externe referenz bietet sich an}. Wenn die Auswahl besteht, sollte daher immer die \gls{ssh}-Variante vorgezogen werden.

% subsubsection vergleich_der_deployment_varianten (end)

% subsection Übertragung_der_dateien (end)

% section sec:architektur_und_umsetzung (end)

\section{Zusammenfassung und Ausblick} % (fold)
\label{sec:zusammenfassung_und_ausblick}
% - Was kann's? -> Highlights
% - Was wird in naher Zeit umgesetzt?
% - Was sind die Visionen?
% - evtl. Diskussion von Alternativen
% section zusammenfassung_und_ausblick (end)
